<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>5m地形変化量表示マップ</title>
  <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>
  <script src="src/plugins/leaflet-tilelayer-glue.js"></script>
  <style>
    #map {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }
    .legend {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      font-size: 12px;
      line-height: 18px;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <script>
    var map = L.map("map", {
      zoom: 11,
      maxZoom: 16,
      center: [37.38906, 136.90990]
    });

    // -70～+70m対応のカラーマップ用シェーダー
    // 西岡他（2015）の標高計算ルールに基づく
    var colorMapShader = `
precision mediump float;
uniform sampler2D image;
uniform vec2 unit;
uniform float zoom;

// 西岡他（2015）に基づく標高値計算関数
float calculateAltitude(vec3 rgb) {
  float x = rgb.r * 16711680.0 + rgb.g * 65280.0 + rgb.b * 255.0;
  float u = 0.01; // 標高分解能
  
  if (x < 8388608.0) {
    return x * u;
  } else if (abs(x - 8388608.0) < 1.0) {
    return -9999.0; // NA値
  } else if (x > 8388608.0) {
    return (x - 16777216.0) * u;
  } else {
    return -9999.0; // 無効な値
  }
}


// -70～+70m対応のカラーマップ
vec3 getColor(float altitude) {
  if (altitude < -10.0) {
    // -70～-10m:5m毎（12段階）紫～青のグラデーション
    int level = int((altitude + 70.0) / 5.0);
    if (level == 0) return vec3(0.4, 0.0, 0.6);    // -70～-65m: 濃紫
    if (level == 1) return vec3(0.45, 0.0, 0.65);  // -65～-60m: 紫
    if (level == 2) return vec3(0.5, 0.0, 0.7);    // -60～-55m: 紫
    if (level == 3) return vec3(0.45, 0.1, 0.8);   // -55～-50m: 紫青
    if (level == 4) return vec3(0.4, 0.2, 0.9);    // -50～-45m: 紫青
    if (level == 5) return vec3(0.3, 0.3, 1.0);    // -45～-40m: 紫青
    if (level == 6) return vec3(0.2, 0.4, 1.0);    // -40～-35m: 青紫
    if (level == 7) return vec3(0.1, 0.5, 1.0);    // -35～-30m: 青
    if (level == 8) return vec3(0.0, 0.6, 1.0);    // -30～-25m: 青
    if (level == 9) return vec3(0.0, 0.7, 0.95);   // -25～-20m: 青
    if (level == 10) return vec3(0.0, 0.8, 0.9);   // -20～-15m: 水色
    if (level == 11) return vec3(0.0, 0.85, 0.85); // -15～-10m: 浅水色
  } else if (altitude <= 0.0) {
    // -10～0m:1m毎（10段階）青～緑のグラデーション
    int level = int(altitude);
    if (level <= -10) return vec3(0.0, 0.85, 0.8);   // -10以下
    if (level == -9) return vec3(0.05, 0.85, 0.75);  // -9～-8m
    if (level == -8) return vec3(0.1, 0.85, 0.7);    // -8～-7m
    if (level == -7) return vec3(0.15, 0.87, 0.65);  // -7～-6m
    if (level == -6) return vec3(0.2, 0.9, 0.6);     // -6～-5m
    if (level == -5) return vec3(0.3, 0.92, 0.5);    // -5～-4m
    if (level == -4) return vec3(0.4, 0.94, 0.4);    // -4～-3m
    if (level == -3) return vec3(0.5, 0.95, 0.3);    // -3～-2m
    if (level == -2) return vec3(0.6, 0.96, 0.2);    // -2～-1m
    return vec3(0.0, 0.0, 0.0);                     // -1～0m（-0.1mなど0に近い値）
  } else if (altitude < 10.0) {
    // 0～10m:1m毎（10段階）緑～黄～赤のグラデーション
    int level = int(altitude);
    if (level == 0) return vec3(0.0, 0.3, 0.0);    // 0-1m: 灰
    if (level == 1) return vec3(0.2, 0.98, 0.0);   // 1-2m: 黄緑
    if (level == 2) return vec3(0.4, 0.96, 0.0);   // 2-3m: 黄緑
    if (level == 3) return vec3(0.6, 0.94, 0.0);   // 3-4m: 黄
    if (level == 4) return vec3(0.8, 0.92, 0.0);   // 4-5m: 黄
    if (level == 5) return vec3(1.0, 0.8, 0.0);    // 5-6m: オレンジ黄
    if (level == 6) return vec3(1.0, 0.6, 0.0);    // 6-7m: オレンジ
    if (level == 7) return vec3(1.0, 0.4, 0.0);    // 7-8m: 赤オレンジ
    if (level == 8) return vec3(1.0, 0.2, 0.0);    // 8-9m: 赤
    if (level == 9) return vec3(0.95, 0.0, 0.05);  // 9-10m: 赤
  } else {
    // 10m以上は5m毎（14段階）赤～茶色のグラデーション
    int level = int((altitude - 10.0) / 5.0);
    if (level == 0) return vec3(0.9, 0.0, 0.1);     // 10-15m: 赤
    if (level == 1) return vec3(0.85, 0.0, 0.15);   // 15-20m: 赤
    if (level == 2) return vec3(0.8, 0.05, 0.2);    // 20-25m: 暗赤
    if (level == 3) return vec3(0.75, 0.1, 0.15);   // 25-30m: 暗赤
    if (level == 4) return vec3(0.7, 0.15, 0.1);    // 30-35m: 赤茶
    if (level == 5) return vec3(0.65, 0.2, 0.05);   // 35-40m: 赤茶
    if (level == 6) return vec3(0.65, 0.3, 0.0);    // 40-45m: 茶色
    if (level == 7) return vec3(0.6, 0.35, 0.0);    // 45-50m: 茶色
    if (level == 8) return vec3(0.55, 0.4, 0.0);    // 50-55m: 茶色
    if (level == 9) return vec3(0.5, 0.3, 0.0);     // 55-60m: 濃茶
    if (level == 10) return vec3(0.45, 0.25, 0.05); // 60-65m: 濃茶
    if (level == 11) return vec3(0.4, 0.2, 0.1);    // 65-70m: 濃茶紫
    if (level == 12) return vec3(0.35, 0.15, 0.15); // 70-75m: 暗茶
    return vec3(0.3, 0.1, 0.2);                     // 75m以上: 最濃茶
  }
  return vec3(0.5, 0.5, 0.5);
}

void main() {
  vec2 p = vec2(gl_FragCoord.x, 1.0 / unit.y - gl_FragCoord.y);
  
  // 標高値を計算
  vec4 pixelColor = texture2D(image, p * unit);
  float alt = calculateAltitude(pixelColor.rgb);
  
  // NA値（-9999）の場合は透明
  if (alt < -9998.0) {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    return;
  }
  
  // 色を取得
  vec3 color = getColor(alt);
  
  // 無効なデータは透明化
  float alpha = (alt >= -70.0 && alt <= 75.0) ? 1.0 : 0.0;
  
  gl_FragColor = vec4(color, alpha);
}
    `;

    // -50～+55m対応の等高線表示用シェーダー
    var contourShader = `
precision mediump float;
uniform sampler2D image;
uniform vec2 unit;
uniform float zoom;

// 西岡他（2015）に基づく標高値計算関数
float calculateAltitude(vec3 rgb) {
  float x = rgb.r * 16711680.0 + rgb.g * 65280.0 + rgb.b * 255.0;
  float u = 0.01; // 標高分解能
  
  if (x < 8388608.0) {
    return x * u;
  } else if (abs(x - 8388608.0) < 1.0) {
    return -9999.0; // NA値
  } else if (x > 8388608.0) {
    return (x - 16777216.0) * u;
  } else {
    return -9999.0; // 無効な値
  }
}

int getLevel(float altitude) {
  if (altitude < -10.0) {
    return int((altitude + 70.0) / 5.0);
  } else if (altitude < 10.0) {
    return 12 + int(altitude);
  } else {
    return 22 + int((altitude - 10.0) / 5.0);
  }
}

vec3 getColor(float altitude) {
  if (altitude < -10.0) {
    // -70～-10m:5m毎（12段階）紫～青のグラデーション
    int level = int((altitude + 70.0) / 5.0);
    if (level == 0) return vec3(0.4, 0.0, 0.6);    // -70～-65m: 濃紫
    if (level == 1) return vec3(0.45, 0.0, 0.65);  // -65～-60m: 紫
    if (level == 2) return vec3(0.5, 0.0, 0.7);    // -60～-55m: 紫
    if (level == 3) return vec3(0.45, 0.1, 0.8);   // -55～-50m: 紫青
    if (level == 4) return vec3(0.4, 0.2, 0.9);    // -50～-45m: 紫青
    if (level == 5) return vec3(0.3, 0.3, 1.0);    // -45～-40m: 紫青
    if (level == 6) return vec3(0.2, 0.4, 1.0);    // -40～-35m: 青紫
    if (level == 7) return vec3(0.1, 0.5, 1.0);    // -35～-30m: 青
    if (level == 8) return vec3(0.0, 0.6, 1.0);    // -30～-25m: 青
    if (level == 9) return vec3(0.0, 0.7, 0.95);   // -25～-20m: 青
    if (level == 10) return vec3(0.0, 0.8, 0.9);   // -20～-15m: 水色
    if (level == 11) return vec3(0.0, 0.85, 0.85); // -15～-10m: 浅水色
  } else if (altitude <= 0.0) {
    // -10～0m:1m毎（10段階）青～緑のグラデーション
    int level = int(altitude);
    if (level <= -10) return vec3(0.0, 0.85, 0.8);   // -10以下
    if (level == -9) return vec3(0.05, 0.85, 0.75);  // -9～-8m
    if (level == -8) return vec3(0.1, 0.85, 0.7);    // -8～-7m
    if (level == -7) return vec3(0.15, 0.87, 0.65);  // -7～-6m
    if (level == -6) return vec3(0.2, 0.9, 0.6);     // -6～-5m
    if (level == -5) return vec3(0.3, 0.92, 0.5);    // -5～-4m
    if (level == -4) return vec3(0.4, 0.94, 0.4);    // -4～-3m
    if (level == -3) return vec3(0.5, 0.95, 0.3);    // -3～-2m
    if (level == -2) return vec3(0.6, 0.96, 0.2);    // -2～-1m
   return vec3(0.0, 0.0, 0.0);                     // -1～0m（-0.1mなど0に近い値）
  } else if (altitude < 10.0) {
    // 0～10m:1m毎（10段階）緑～黄～赤のグラデーション
    int level = int(altitude);
    if (level == 0) return vec3(0.0, 0.3, 0.0);    // 0-1m: 灰
    if (level == 1) return vec3(0.2, 0.98, 0.0);   // 1-2m: 黄緑
    if (level == 2) return vec3(0.4, 0.96, 0.0);   // 2-3m: 黄緑
    if (level == 3) return vec3(0.6, 0.94, 0.0);   // 3-4m: 黄
    if (level == 4) return vec3(0.8, 0.92, 0.0);   // 4-5m: 黄
    if (level == 5) return vec3(1.0, 0.8, 0.0);    // 5-6m: オレンジ黄
    if (level == 6) return vec3(1.0, 0.6, 0.0);    // 6-7m: オレンジ
    if (level == 7) return vec3(1.0, 0.4, 0.0);    // 7-8m: 赤オレンジ
    if (level == 8) return vec3(1.0, 0.2, 0.0);    // 8-9m: 赤
    if (level == 9) return vec3(0.95, 0.0, 0.05);  // 9-10m: 赤
  } else {
    // 10m以上は5m毎（14段階）赤～茶色のグラデーション
    int level = int((altitude - 10.0) / 5.0);
    if (level == 0) return vec3(0.9, 0.0, 0.1);     // 10-15m: 赤
    if (level == 1) return vec3(0.85, 0.0, 0.15);   // 15-20m: 赤
    if (level == 2) return vec3(0.8, 0.05, 0.2);    // 20-25m: 暗赤
    if (level == 3) return vec3(0.75, 0.1, 0.15);   // 25-30m: 暗赤
    if (level == 4) return vec3(0.7, 0.15, 0.1);    // 30-35m: 赤茶
    if (level == 5) return vec3(0.65, 0.2, 0.05);   // 35-40m: 赤茶
    if (level == 6) return vec3(0.65, 0.3, 0.0);    // 40-45m: 茶色
    if (level == 7) return vec3(0.6, 0.35, 0.0);    // 45-50m: 茶色
    if (level == 8) return vec3(0.55, 0.4, 0.0);    // 50-55m: 茶色
    if (level == 9) return vec3(0.5, 0.3, 0.0);     // 55-60m: 濃茶
    if (level == 10) return vec3(0.45, 0.25, 0.05); // 60-65m: 濃茶
    if (level == 11) return vec3(0.4, 0.2, 0.1);    // 65-70m: 濃茶紫
    if (level == 12) return vec3(0.35, 0.15, 0.15); // 70-75m: 暗茶
    return vec3(0.3, 0.1, 0.2);                     // 75m以上: 最濃茶
  }
  return vec3(0.5, 0.5, 0.5);
}

void main() {
  vec2 p = vec2(gl_FragCoord.x, 1.0 / unit.y - gl_FragCoord.y);
  
  // 標高値を計算（複数ポイント）
  vec4 c1 = texture2D(image, (p + vec2(0.0, 0.0)) * unit);
  vec4 c2 = texture2D(image, (p + vec2(1.0, 0.0)) * unit);
  vec4 c3 = texture2D(image, (p + vec2(0.0, 1.0)) * unit);
  vec4 c4 = texture2D(image, (p + vec2(1.0, 1.0)) * unit);
  
  float h1 = calculateAltitude(c1.rgb);
  float h2 = calculateAltitude(c2.rgb);
  float h3 = calculateAltitude(c3.rgb);
  float h4 = calculateAltitude(c4.rgb);
  
  // レベルを計算
  int level1 = getLevel(h1);
  int level2 = getLevel(h2);
  int level3 = getLevel(h3);
  int level4 = getLevel(h4);
  
  vec3 baseColor = getColor(h1);
  
  // 等高線の描画（境界を黒くする）
  float contourAlpha = (level1 != level2 || level1 != level3 || level1 != level4) ? 0.5 : 0.3;
  
  gl_FragColor = vec4(baseColor, contourAlpha);
}
    `;

    // 背景レイヤーの作成
    var baseMapLayer = L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png", {
      attribution: "国土地理院",
      maxZoom: 18
    });
    baseMapLayer.addTo(map);

    // レイヤーグループの作成
    var baseLayers = {
      "5m色別": L.tileLayer.glue("https://forestgeo.info/opendata/17_ishikawa/noto/henka_2024/{z}/{x}/{y}.png", {
        attribution: "Forestry Agency",
        maxZoom: 16,
        maxNativeZoom: 14,
        opacity: 0.5,
        fragmentShader: colorMapShader
      }).addTo(map),
      
      "林野庁・簡易オルソ画像": L.tileLayer("https://forestgeo.info/opendata/17_ishikawa/noto/orthophoto_2024/{z}/{x}/{y}.webp", {
        attribution: "林野庁",
        maxZoom: 16,
        maxNativeZoom: 14
      }),
      
      "CSMap": L.tileLayer("https://forestgeo.info/opendata/17_ishikawa/noto/csmap_2024/{z}/{x}/{y}.webp", {
        attribution: "林野庁",
        maxZoom: 16,
        maxNativeZoom: 14
      })
    };
    
    var overlayLayers = {};
    var layerControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
    
    // GeoJSONレイヤーの読み込み
    fetch('src/maff_json/jisuberi.geojson')
      .then(response => response.json())
      .then(data => {
        var jisuberiLayer = L.geoJSON(data, {
          style: {
            color: "#8B4513",
            weight: 2,
            opacity: 0.8,
            fillColor: "#8B4513",
            fillOpacity: 0
          },
          onEachFeature: function(feature, layer) {
            if (feature.properties) {
              var popupContent = '<div>';
              for (var key in feature.properties) {
                popupContent += '<b>' + key + ':</b> ' + feature.properties[key] + '<br>';
              }
              popupContent += '</div>';
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);
        
        // レイヤーコントロールにオーバーレイを追加
        layerControl.addOverlay(jisuberiLayer, "地すべり");
      })
      .catch(err => console.log('jisuberi.geojson load error:', err));

    // houkai.geojsonの読み込み
    fetch('src/maff_json/houkai.geojson')
      .then(response => response.json())
      .then(data => {
        var houkaiLayer = L.geoJSON(data, {
          style: {
            color: "#000000",
            weight: 2,
            opacity: 0.8,
            fillColor: "#000000",
            fillOpacity: 0
          },
          onEachFeature: function(feature, layer) {
            if (feature.properties) {
              var popupContent = '<div>';
              for (var key in feature.properties) {
                popupContent += '<b>' + key + ':</b> ' + feature.properties[key] + '<br>';
              }
              popupContent += '</div>';
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);
        
        // レイヤーコントロールにオーバーレイを追加
        layerControl.addOverlay(houkaiLayer, "崩壊");
      })
      .catch(err => console.log('houkai.geojson load error:', err));

    // taiseki.geojsonの読み込み
    fetch('src/maff_json/taiseki.geojson')
      .then(response => response.json())
      .then(data => {
        var taisekinLayer = L.geoJSON(data, {
          style: {
            color: "#0000FF",
            weight: 2,
            opacity: 0.8,
            fillColor: "#0000FF",
            fillOpacity: 0
          },
          onEachFeature: function(feature, layer) {
            if (feature.properties) {
              var popupContent = '<div>';
              for (var key in feature.properties) {
                popupContent += '<b>' + key + ':</b> ' + feature.properties[key] + '<br>';
              }
              popupContent += '</div>';
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);
        
        // レイヤーコントロールにオーバーレイを追加
        layerControl.addOverlay(taisekinLayer, "堆積域");
      })
      .catch(err => console.log('taiseki.geojson load error:', err));

    // 凡例の追加
    var legend = L.control({ position: 'bottomleft' });

    legend.onAdd = function(map) {
      var div = L.DomUtil.create('div', 'legend');
      var labels = [
        ['-70～-65m', 'rgb(102, 0, 153)'],
        ['-65～-60m', 'rgb(115, 0, 166)'],
        ['-60～-55m', 'rgb(128, 0, 179)'],
        ['-55～-50m', 'rgb(115, 26, 204)'],
        ['-50～-45m', 'rgb(102, 51, 230)'],
        ['-45～-40m', 'rgb(77, 77, 255)'],
        ['-40～-35m', 'rgb(51, 102, 255)'],
        ['-35～-30m', 'rgb(26, 128, 255)'],
        ['-30～-25m', 'rgb(0, 153, 255)'],
        ['-25～-20m', 'rgb(0, 179, 242)'],
        ['-20～-15m', 'rgb(0, 204, 230)'],
        ['-15～-10m', 'rgb(0, 217, 217)'],
        ['-10～-9m', 'rgb(0, 217, 204)'],
        ['-9～-8m', 'rgb(13, 217, 191)'],
        ['-8～-7m', 'rgb(26, 217, 178)'],
        ['-7～-6m', 'rgb(38, 217, 165)'],
        ['-6～-5m', 'rgb(51, 230, 153)'],
        ['-5～-4m', 'rgb(77, 240, 102)'],
        ['-4～-3m', 'rgb(102, 240, 102)'],
        ['-3～-2m', 'rgb(128, 245, 77)'],
        ['-2～-1m', 'rgb(153, 245, 51)'],
        ['-1～0m', 'rgb(0, 0, 0)'],
        ['0-1m', 'rgb(0, 77, 0)'],
        ['1-2m', 'rgb(51, 250, 0)'],
        ['2-3m', 'rgb(102, 245, 0)'],
        ['3-4m', 'rgb(153, 240, 0)'],
        ['4-5m', 'rgb(204, 235, 0)'],
        ['5-6m', 'rgb(255, 204, 0)'],
        ['6-7m', 'rgb(255, 153, 0)'],
        ['7-8m', 'rgb(255, 102, 0)'],
        ['8-9m', 'rgb(255, 51, 0)'],
        ['9-10m', 'rgb(242, 0, 13)'],
        ['10-15m', 'rgb(230, 0, 26)'],
        ['15-20m', 'rgb(217, 0, 38)'],
        ['20-25m', 'rgb(204, 13, 51)'],
        ['25-30m', 'rgb(191, 26, 38)'],
        ['30-35m', 'rgb(179, 38, 26)'],
        ['35-40m', 'rgb(166, 51, 13)'],
        ['40-45m', 'rgb(166, 77, 0)'],
        ['45-50m', 'rgb(153, 89, 0)'],
        ['50-55m', 'rgb(128, 77, 0)'],
        ['55-60m', 'rgb(128, 77, 0)'],
        ['60-65m', 'rgb(115, 64, 13)'],
        ['65-70m', 'rgb(102, 51, 26)'],
        ['70m以上', 'rgb(77, 26, 51)']
      ];

      labels.forEach(function(label) {
        var item = document.createElement('div');
        item.innerHTML = '<i style="background:' + label[1] + '"></i> ' + label[0];
        div.appendChild(item);
      });

      return div;
    };

    legend.addTo(map);

    // JavaScript内で標高値を計算する関数
    function calculateAltitudeJS(r, g, b) {
      var x = r * 16711680.0 + g * 65280.0 + b * 255.0;
      var u = 0.01;
      
      if (x < 8388608.0) {
        return x * u;
      } else if (x === 8388608.0) {
        return -9999.0;
      } else {
        return (x - 16777216.0) * u;
      }
    }

    // マップクリック時に標高値を取得
    map.on('click', function(e) {
      var latlng = e.latlng;
      var zoom = map.getZoom();
      
      // Web Mercator投影を使用してタイル座標を計算
      var earthCircumference = 40075016.686;
      var x = (latlng.lng + 180) / 360 * Math.pow(2, zoom);
      var y = (1 - Math.log(Math.tan(latlng.lat * Math.PI / 180) + 1 / Math.cos(latlng.lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);
      
      var tileX = Math.floor(x);
      var tileY = Math.floor(y);
      var pixelX = Math.floor((x - tileX) * 256);
      var pixelY = Math.floor((y - tileY) * 256);
      
      // タイルのURL
      var tileUrl = "https://forestgeo.info/opendata/17_ishikawa/noto/henka_2024/" + zoom + "/" + tileX + "/" + tileY + ".png";
      
      // 画像を読み込んでピクセルデータを取得
      var img = new Image();
      img.crossOrigin = "anonymous";
      
      img.onload = function() {
        var canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        var imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
        var data = imageData.data;
        
        // RGB値を0-1の範囲に正規化
        var r = data[0] / 255.0;
        var g = data[1] / 255.0;
        var b = data[2] / 255.0;
        
        var altitude = calculateAltitudeJS(r, g, b);
        
        // ポップアップを表示
        if (altitude === -9999.0) {
          L.popup()
            .setLatLng(latlng)
            .setContent('変化量: NA（データなし）')
            .openOn(map);
        } else {
          L.popup()
            .setLatLng(latlng)
            .setContent('変化量: ' + altitude.toFixed(2) + ' m<br/>座標: ' + latlng.lat.toFixed(5) + ', ' + latlng.lng.toFixed(5))
            .openOn(map);
        }
      };
      
      img.onerror = function() {
        L.popup()
          .setLatLng(latlng)
          .setContent('タイルデータの読み込みに失敗しました')
          .openOn(map);
      };
      
      img.src = tileUrl;
    });
  </script>
</body>

</html>
